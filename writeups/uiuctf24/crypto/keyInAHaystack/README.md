
## Key In A Haystack

### Setup
- The flag is encrypted with a random 40-bit prime, and we are given the ciphertext.
- This 40-bit prime is multiplied by 300 different 1024-bit primes and we are given the result.
---
### tl;dr
- The number is too large to fully factorise but we only need to get the smallest factor.
- I used the [ECM](https://en.wikipedia.org/wiki/Lenstra_elliptic-curve_factorization) algorithm because it is 'most suitable for finding small factors' (wikipedia)
- We also know that the factor we are looking for is 40-bit (i.e 2^39 <= p < 2^40) so we may be able to choose our bounds for ECM to optimise for this case.
---
It's possible to solve this with little (human) effort by putting the haystack number into [Alpertron](https://www.alpertron.com.ar/ECM.HTM) and waiting until it gives a factor. This took me 2 hours though, so after the CTF I looked for a faster way.


I heard about `gmp-ecm` from [rubixcyouber](https://discord.com/channels/722150434566963293/1257123741356265522/1257129480468824144) from the uiuctf discord and gave it a try.
If you were solving this by yourself you might've found `gmp-ecm` from searching "ecm factoring method github" which gives [another tool](https://github.com/GiacomoPope/LenstraECM) which mentions `gmp-ecm` as a faster alternative. Or from sage, `gmp-ecm` is the tool used in sage to do [ECM](https://doc.sagemath.org/html/en/reference/interfaces/sage/interfaces/ecm.html). Or, you could find another tool and use that.

From [this documentation](https://www.systutorials.com/docs/linux/man/1-gmp-ecm/) and help from ChatGPT, I learned that a larger `B1` gives a higher probability of finding a factor per curve, but a larger running time, so I have to find a `B1` which is low but doesn't take too many curves to find the prime.

I tested different values of `B1` for a smaller test number to see what was optimal.
My test number had ~10x less digits but the smallest prime factor was still 40 bits. (I assumed that this similarity would mean the optimal B1 is roughly the same)
Also, I didn't worry about `B2` because it is auto generated by `gmp-ecm`.

Here are my test values:
| B1   | time 1| time 2 | time 3|
|------|-------|--------|-------|
| 500  | 12s   | 36s    | 61s   |
| 750  | 20s   | 11s    |    -  |
| 1000 | 9s    | 7s     | 40s   |
| 2000 | 54s   | 12s    | 20s   |
| 5000 | 20s   | 19s    |    -  |
| 8000 | 30s   | -      |   -   |
| 10000| 76s   | -      |    -  |

There is a huge variation in the times but I just tried `B1` = `750` for the real haystack and it worked in only 6 minutes:

```
$ time ecm -c 100 750 < toFactor.txt 
...
...
...
Run 8 out of 100:
Using B1=750, B2=35710, polynomial x^1, sigma=0:8629760470374597727
Step 1 took 32449ms
Step 2 took 15796ms
********** Factor found in step 2: 859914774577
^C
real    6m38.696s
user    6m38.272s
sys     0m0.400s
```
`859914774577` is the factor we are looking for and we can use it as the key to decrypt the flag:
```py
from Crypto.Util.Padding import unpad
from Crypto.Cipher import AES
from hashlib import md5

# slightly modified from chal.py
def decrypt(key, ct):
    pt = AES.new(
        key = md5(b"%d" % key).digest(),
        mode = AES.MODE_ECB
    ).decrypt(ct)
    return unpad(pt, 16).decode()

# from server
enc_flag = bytes.fromhex("734aa343a8e1e4ec4acab8365b063e9e6514eb56941a39ac3ddc2837d596017fcb366400c3e192e88c17a5b6b3370a9c")

key = 859914774577
print(decrypt(key, enc_flag))
```
---
### Afterthoughts
- I would have benefit from having a proper understanding of the different factorisation algorithms (more than skimming the wikipedia page!!!) - that probably would have helped me find what `B1` to use without all the testing,
- I also learned from [BerlianGabriel](https://discord.com/channels/722150434566963293/1257123741356265522/1257128481788268657) (from uiuctf discord) that Pollard's p-1 algorithm would have been better in this case (I just naively committed to ecm because it's generally faster)
- There is an [unintended solution by sahuang](https://discord.com/channels/722150434566963293/1257123741356265522/1257145905388457984) where they notice how fast the server-side code runs. Noticing that is probably a useful skill in other categories - not that I know, I don't do other categories

